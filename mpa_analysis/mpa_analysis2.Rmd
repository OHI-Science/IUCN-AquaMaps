---
title: 'MPA Gap Analysis: IUCN and AquaMaps'
output: html_document
---
  
```{r setup, echo = FALSE, warning = FALSE, message = FALSE}

# Libraries and Paths

library(rgdal)
library(maptools)
library(raster)
library(readr)
library(tidyr)
library(dplyr)
library(stringr)
library(rgeos)

dir_N <- c('Windows' = '//neptune.nceas.ucsb.edu/data_edit',
           'Darwin'  = '/Volumes/data_edit',
           'Linux'   = '/var/data/ohi')[[ Sys.info()[['sysname']] ]]

dir_git <- '~/github/IUCN-AquaMaps'

dir_anx <- file.path(dir_N, 'git-annex/globalprep/SPP_ICO')
dir_fig <- file.path(dir_git, 'figures')
dir_data <- file.path(dir_git, 'data')

if(basename(getwd()) != 'IUCN-AquaMaps') setwd(dir_git)

### When knitting this, it automatically sets WD to be this directory...
### the 'setwd()' is there for running by chunk
```

# MPA gap analysis

Several steps to this:
  
  * set up WDPA database in a raster format for easy use
* perform gap analysis for WDPA-MPA data base (which year?) vs AquaMaps 2014, with 50% threshold - replicate the original analysis
* reperform the analysis with latest/greatest WDPA-MPA database, and AquaMaps 2015, with 50% threshold and 0% threshold
* perform the analysis with latest/greatest WDPA-MPA database, and IUCN shapefiles

## set up WDPA raster

* direct extract method: extract WDPA polygons against half-degree cells, with proportion; value = year (or combo code)
* all protected areas
* 'marine' = 1
* 'marine' = 1 and IUCN I - IV
* clip WDPA to ocean regions, then IUCN I - IV.
* NOTE: using extract() could result in double-counting - at least make sure total protected area per cell is not greater than 1.
* maybe check any cells with protection > 50% and protected areas n > 1?
* this method would be excruciatingly slow.
* to avoid double-counting for overlapping polygons - rasterize WDPA to fine scale first
* less than 1km^2^ was mentioned in paper as resolution of MPA data.  Rasterize to 0.01 degree x 0.01 degree?  
* this results in max cell size of 1.11 km x 1.11 km at the equator.
* -180 to +180 longitude; min/max latitude use min/max from AquaMaps
* WDPA_MPA layer: value = IUCN category (1-4, with NA = 7?) combined with marine flag and marine overlap flag?
* first digit IUCN category; second digit marine flag; third digit marine overlap?
* rasterize by IUCN category (unprotected, call NA?)
* then rasterize again by marine field (0 or 1)
* then rasterize land (or ocean) (0 or 1)
* then add 'em up to construct full raster at 0.01 degree resolution
* for year-to-year analysis, could recreate this layer for older years by filtering out newer protected areas
* this allows for a cell's protection class to change over time?
* could do this every, say, 5 years - to more quickly capture the trend across a span of, say, 25 years.
* Cell area layer: use raster::area() to create a single layer of cell areas at this new resolution.
* aggregate cells up to 0.5 degree cells, by protected area within each cell for each type of analysis
* summarize to data.frame of loiczid, with area of protection (and total area?)?
* create different protected-area layer for each protection scenario
* AquaMaps layer: use as is
* To analyze for each species:
  * Summarize total area and total protected area (for a given protection scenario) for the species
* Include species extinction risk in there too?

``` {r set_up_base_raster}
### base raster will contain 0.01 degree cells from -180 to +180,
### and -90 to +90, with the associated area of each cell.
### Save it as a .tif in GitHub - about 50 
rast_base_file <- file.path(dir_git, 'mpa_analysis/rast_base.tif')

if(!file.exists(rast_base_file)) {
  ### import AquaMaps half-degree loiczid raster - for extents and such
  rast_loiczid_file   <- file.path(dir_git, 'data/rasters/loiczid_raster.grd')
  rast_loiczid        <- raster(rast_loiczid_file)
  names(rast_loiczid) <- 'loiczid'
  
  rast_empty <- raster(ext = extent(rast_loiczid), resolution = 0.02)
  rast_base  <- raster::area(rast_empty) ### takes a while...
  
  writeRaster(rast_base, rast_base_file, overwrite = TRUE)
} else {
  rast_base <- raster(rast_base_file)
}



```

Dealing with rasters: 
  
  * how to ensure 1 km or better resolution?  WGS84 at 0.01 degree or Mollweide at 1 km
* WGS84 --> 36000 * 18000 cells = 648,000,000 cells...
* Mollweide --> 
  * options for creating rasters
* use arcpy as in LSP... global Mollweide raster of WDPA is about 50 MB; includes .tif and supporting files.  This is .5 km raster.  How is it so small?
* use gdal_rasterize seems to create multi-GB rasters; .tif only
* why rasters?  avoid double-counting for overlapping parks.  WDPA is most important, but since that is in raster and AM is raster, easiest to keep it all in raster
* WDPA - capture park classification and year and marine flag
* spatial marine - capture whether cell includes ocean or not - clip to max N and S of WDPA?
* xMin,yMin -180.007,-72.95 : xMax,yMax 180,83.73
* Use this R script to source arcPy script modified from LSP - need to run it on a PC with appropriate GDAL installation, most likely


``` {r set_up_spatially_marine_raster}

### This raster (at 0.01 degree resolution) contains flags on whether a cell
### is "spatially marine" - i.e. overlaps (center?) with an ocean area.
### This is separate from the WDPA "marine" flag.

### set up some objects for WGS 84 projection
p4s_wgs84 <- '+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'
crs_wgs84 <- CRS(p4s_wgs84)

poly_dir <- file.path(dir_anx, 'explore_am_v_iucn/mpa_rasters')
rast_dir <- file.path(dir_anx, 'explore_am_v_iucn/mpa_rasters')

dir_rgn   <- file.path(dir_N, 'git-annex/globalprep/spatial/v2015/data')
lyr_rgn <- 'regions_gcs'
poly_marine <- readShapePoly(file.path(dir_rgn, lyr_rgn), 
                             proj4string = crs_wgs84)

### filter out all polygons that are land or landlocked, and flag 
### the rest as spatially-marine = 1

poly_marine <- poly_marine[!str_detect(poly_marine@data$rgn_typ, 'land'), ]
poly_list <- list()
poly_list[['poly_fao']]     <- poly_marine[str_detect(poly_marine@data$ant_typ, 'fao'), ]
poly_list[['poly_ccamlr']]  <- poly_marine[str_detect(poly_marine@data$ant_typ, 'ccamlr'), ]
poly_list[['poly_disp']]    <- poly_marine[str_detect(poly_marine@data$ant_typ, 'disputed'), ]
poly_eez    <- poly_marine[!(str_detect(poly_marine@data$ant_typ, 'ccamlr')) & 
                           !(str_detect(poly_marine@data$ant_typ, 'fao'))   &
                           !(str_detect(poly_marine@data$ant_typ, 'disputed')), ]
n_eez <- 5
for (i in 1:ceiling(nrow(poly_eez)/n_eez)) {
  min_row <- n_eez * (i - 1) + 1
  max_row <- n_eez * i
  poly_list[[paste('poly_eez', i, sep = '')]] <- poly_eez[min_row:max_row, ]
}

for (fn in names(poly_list)) { # fn = names(poly_list)[1] 
  message('Simplifying polygon ', fn)
  poly_list[[fn]] <- poly_simplify(poly_list[[fn]], thresh = 1e-5, verbose = TRUE)

#   if(!gIsValid(poly_list[[fn]], byid = TRUE, reason = TRUE)) {
#     message('INVALID POLYGONS FOUND in polygon ', fn)
#   }
  message('Writing polygon ', fn)
  writeOGR(obj    = poly_list[[fn]],
           dsn    = path.expand(poly_dir),
           layer  = fn,
           driver = 'ESRI Shapefile',
           overwrite_layer = TRUE,
           verbose = TRUE)
}


```

``` {r turn saved files into rasters}
poly_names <- names(poly_list)
remove(poly_list, poly_eez, poly_marine)

ext  <- c(-180, -90, 180, 90), 
          # extents for output raster
reso <- c(.05, .05),  


# tmpdir <- '~/home_big/ohara/R_raster_tmp'
# dir.create(tmpdir, showWarnings = FALSE)
# rasterOptions(tmpdir = tmpdir)

### gdalUtils::gdal_rasterize() method:
for (fn in poly_names) { # fn = poly_names[1]
  message('Rasterizing polygon ', fn)
  
  src <- path.expand(file.path(poly_dir, paste(fn, '.shp', sep = '')))
  rfn <- str_replace(fn, 'poly', 'rast') 
  tmp_dst <- file.path(rast_dir, 'tmp', paste(rfn, '.tif', sep = '')) %>%
    path.expand
  fnl_dst <- file.path(rast_dir, paste(rfn, '.tif', sep = '')) %>%
    path.expand
  
# if(!file.exists(fnl_dst)) {
#     if(file.size(src) > 7e6) {
#       message(sprintf('%s: Too damn big... %.2f', src, file.size(src)/1e6))
#     } else {
      ptm <- proc.time()
      tmp_rast <- gdalUtils::gdal_rasterize(
        src_datasource = src,
        dst_filename   = tmp_dst, 
          # destination for output
        a = 'rgn_id', 
          # the attribute in the shapefile to be assigned to the cell values
        te = ext, 
          # extents for output raster
        tr = reso,  
          # resolution for output raster
        a_nodata = NA, 
          # nodata value for raster; otherwise they will be filled in with zeroes
        output_Raster = TRUE,
          # return output as a RasterBrick? 
        verbose = TRUE)
      message('Rasterized ', rfn, '; ', (proc.time() - ptm)[3], ' seconds')
      
      ptm <- proc.time()
      raster::writeRaster(tmp_rast, fnl_dst, overwrite = TRUE)
      message('Write ', rfn, '; ', (proc.time() - ptm)[3], ' seconds')
      remove(tmp_rast)
      unlink(tmp_dst)
    # }
#   } else {
#     message('File ', fnl_dst, ' already exists.')
#   }
}

```


