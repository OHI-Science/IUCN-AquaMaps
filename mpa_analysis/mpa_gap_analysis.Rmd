---
title: 'MPA Gap Analysis: IUCN and AquaMaps'
output: html_document
---

```{r setup, echo = FALSE, warning = FALSE, message = FALSE}

# Libraries and Paths

library(raster)
library(readr)
library(tidyr)
library(dplyr)
library(stringr)

dir_N <- c('Windows' = '//neptune.nceas.ucsb.edu/data_edit',
           'Darwin'  = '/Volumes/data_edit',
           'Linux'   = '/var/data/ohi')[[ Sys.info()[['sysname']] ]]

dir_git <- '~/github/IUCN-AquaMaps'
  
dir_anx <- file.path(dir_N, 'git-annex/globalprep/SPP_ICO')
dir_fig <- file.path(dir_git, 'figures')
dir_data <- file.path(dir_git, 'data')

if(basename(getwd()) != 'IUCN-AquaMaps') setwd(dir_git)

### When knitting this, it automatically sets WD to be this directory...
### the 'setwd()' is there for running by chunk
```

# MPA gap analysis

Several steps to this:

* set up WDPA database in a raster format for easy use
* perform gap analysis for WDPA-MPA data base (which year?) vs AquaMaps 2014, with 50% threshold - replicate the original analysis
* reperform the analysis with latest/greatest WDPA-MPA database, and AquaMaps 2015, with 50% threshold and 0% threshold
* perform the analysis with latest/greatest WDPA-MPA database, and IUCN shapefiles

## set up WDPA raster

* Create polygon subset of WDPA database
    * STATUS = 'Designated'
    * IUCN_CAT = I - IV
    * Simplify polygons to make it easier for rasterization
        * cut any main polygons less than 10% of a raster cell.  Raster
          cells are .01 x .01 degree, so area = .0001; cut any less than 1e-5.
          Do the same for subpolygons within a larger polygon.
    * Inverse order by `STATUS_YR`, so oldest is at the end (for `gdal_rasterize()`)
* To avoid double-counting for overlapping polygons - rasterize WDPA to fine scale first
    * less than 1km^2^ was mentioned in paper as resolution of MPA data.  
      Rasterize to 0.01 degree x 0.01 degree  
        * this results in max cell size of 1.11 km x 1.11 km at the equator.
    * Use STATUS_YR as field; see note above about ordering polygons
      for use in `gdal_rasterize()`

## Set up marine raster

* Create polygons subset of OHI regions, for only marine regions
* Rasterize to same resolution as above.

## Create raster of WDPA IUCN I-IV and spatially marine

* Intersect the two rasters so only protected areas within spatially marine
  areas are included.

## Aggregate protected area layer to LOICZID scale (0.5 deg)

* Use raster::extract? each LOICZID gets 2500 subcells noting NA (not
  protected) or a value (protected); turn this into proportion of
  LOICZID cell that is protected.
* Also need to do this to find the proportion of LOICZID cell that is
  spatially marine - if not fully marine, the protected proportion will
  be larger; but the area will be smaller (from AquaMaps, or recalc)
    * e.g. a single LOICZID is 60% marine (1500 marine cells), and 48%
      protected (1200 protected cells, which are by def marine).  So
      protected proportion = 48/60 = 80% protection of the marine area
      within this cell.

* AquaMaps layer: use as is
* To analyze for each species:
    * Summarize total area and total protected area (for a given protection scenario) for the species
    * Include species extinction risk in there too?

``` {r set_up_base_raster}
### DO WE NEED THIS? Use area at 0.5 degree level; most cells this will be pretty close.
### base raster will contain 0.01 degree cells from -180 to +180,
### and -90 to +90, with the associated area of each cell.
### Save it as a .tif in GitHub - about 50 
rast_base_file <- file.path(dir_git, 'mpa_analysis/rast_base.tif')

if(!file.exists(rast_base_file)) {
  ### import AquaMaps half-degree loiczid raster - for extents and such
  rast_loiczid_file   <- file.path(dir_git, 'data/rasters/loiczid_raster.grd')
  rast_loiczid        <- raster(rast_loiczid_file)
  names(rast_loiczid) <- 'loiczid'

  rast_empty <- raster(ext = extent(rast_loiczid), resolution = 0.01)
  rast_base  <- raster::area(rast_empty) ### takes a while...
  
  writeRaster(rast_base, rast_base_file, overwrite = TRUE)
} else {
  rast_base <- raster(rast_base_file)
}



```


``` {r load_rasters}

dir_rast <- file.path(dir_anx, 'explore_am_v_iucn/mpa_rasters')
rast_mpa_mar_file <- file.path(dir_rast, 'rast_mpa_mar.tif')
if(!file.exists(rast_mpa_mar_file)) {
  rast_mar_file <- file.path(dir_rast, 'rast_marine.tif')
  rast_mpa_file <- file.path(dir_rast, 'WDPA_poly_Jan2015_mpa1.tif')
  
  rast_mar <- raster(rast_mar_file)
  rast_mpa <- raster(rast_mpa_file)
  
  rast_mpa_mar <- mask(rast_mpa, rast_mar)
  writeRaster(rast_mpa_mar, rast_mpa_mar_file)
} else {
  rast_mar            <- raster(rast_mar_file)
  names(rast_mar)     <- 'rgn_id'
  rast_mpa_mar        <- raster(rast_mpa_mar_file)
  names(rast_mpa_mar) <- 'status_yr'
}

```

``` {r aggregate_to_loiczid}
rast_loiczid_file   <- file.path(dir_git, 'data/rasters/loiczid_raster.grd')
rast_loiczid        <- raster(rast_loiczid_file)
names(rast_loiczid) <- 'loiczid'

rast_loiczid_01_file <- file.path(dir_rast, 'rast_loiczid_01.tif')
rast_loiczid_01 <- resample(rast_loiczid, rast_mpa_mar, method = 'ngb')
writeRaster(rast_loiczid_01, rast_loiczid_01_file)

### Turn all marine cells to value of 1 (so can uze zonal sum)
rast_is_mar <- rast_mar
values(rast_is_mar)[!is.na(values(rast_mar))] <- 1
names(rast_is_mar) <- 'is_marine'

### Turn all MPA cells to value of 1 (so can use zonal sum)
### NOTE: loses status_yr values - so filter by year first
rast_is_mpa <- rast_mpa_mar
values(rast_is_mpa)[!is.na(values(rast_mpa_mar))] <- 1
names(rast_is_mpa) <- 'is_mpa'

rast_test <- rast_test2 <- raster(ext = extent(rast_loiczid), resolution = c(10, 10))
values(rast_test) <- 1:648
values(rast_test2) <- rep(c(1:10), each = 64, length.out = length(rast_test))
x <- zonal(rast_test, rast_test2, fun = sum)
